<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>AFURLSessionManager.m - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../../";
</script>

<script src="../../../../js/jquery.js"></script>
<script src="../../../../js/darkfish.js"></script>

<link href="../../../../css/fonts.css" rel="stylesheet">
<link href="../../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../../../app/controllers/main_view_controller_txt.html">main_view_controller</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_app/PkgInfo.html">PkgInfo</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_app/SintjansGemeenteApp_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_spec_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_spec_app/PkgInfo.html">PkgInfo</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_spec_app/SintjansGemeenteApp_spec_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/objs/init_mm.html">init.mm</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/objs/main_mm.html">main.mm</a>
  
    <li><a href="../../../../design/class structure.html">class structure</a>
  
    <li><a href="../../../../ib_xcodeproj/Stubs_m.html">Stubs.m</a>
  
    <li><a href="../../../../ib_xcodeproj/project_pbxproj.html">project.pbxproj</a>
  
    <li><a href="../../../../ib_xcodeproj/project_xcworkspace/contents_xcworkspacedata.html">contents.xcworkspacedata</a>
  
    <li><a href="../../../../ib_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/ib_xcscheme.html">ib.xcscheme</a>
  
    <li><a href="../../../../ib_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/xcschememanagement_plist.html">xcschememanagement.plist</a>
  
    <li><a href="../../../../requirements/product backlog.html">product backlog</a>
  
    <li><a href="../../../../resources/Main_storyboard.html">Main.storyboard</a>
  
    <li><a href="../../../../vendor/Podfile_lock.html">Podfile.lock</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation_m.html">AFHTTPRequestOperation.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager_m.html">AFHTTPRequestOperationManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager_m.html">AFHTTPSessionManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager_m.html">AFNetworkReachabilityManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFSecurityPolicy_m.html">AFSecurityPolicy.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation_m.html">AFURLConnectionOperation.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization_m.html">AFURLRequestSerialization.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization_m.html">AFURLResponseSerialization.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLSessionManager_m.html">AFURLSessionManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/README_md.html">README</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager_m.html">AFNetworkActivityIndicatorManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking_m.html">UIActivityIndicatorView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking_m.html">UIAlertView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking_m.html">UIButton+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking_m.html">UIImageView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking_m.html">UIProgressView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking_m.html">UIRefreshControl+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking_m.html">UIWebView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/Manifest_lock.html">Manifest.lock</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/project_pbxproj.html">project.pbxproj</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/Pods-AFNetworking_xcscheme.html">Pods-AFNetworking.xcscheme</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/Pods_xcscheme.html">Pods.xcscheme</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/xcschememanagement_plist.html">xcschememanagement.plist</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-Private_xcconfig.html">Pods-AFNetworking-Private.xcconfig</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-dummy_m.html">Pods-AFNetworking-dummy.m</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-prefix_pch.html">Pods-AFNetworking-prefix.pch</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking_xcconfig.html">Pods-AFNetworking.xcconfig</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-acknowledgements_markdown.html">Pods-acknowledgements.markdown</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-acknowledgements_plist.html">Pods-acknowledgements.plist</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-dummy_m.html">Pods-dummy.m</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-resources_sh.html">Pods-resources.sh</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods_debug_xcconfig.html">Pods.debug.xcconfig</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods_release_xcconfig.html">Pods.release.xcconfig</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFHTTPRequestOperation_d.html">AFHTTPRequestOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFHTTPRequestOperationManager_d.html">AFHTTPRequestOperationManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFHTTPSessionManager_d.html">AFHTTPSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFNetworkActivityIndicatorManager_d.html">AFNetworkActivityIndicatorManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFNetworkReachabilityManager_d.html">AFNetworkReachabilityManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFSecurityPolicy_d.html">AFSecurityPolicy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLConnectionOperation_d.html">AFURLConnectionOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLRequestSerialization_d.html">AFURLRequestSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLResponseSerialization_d.html">AFURLResponseSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLSessionManager_d.html">AFURLSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/Pods-AFNetworking-dummy_d.html">Pods-AFNetworking-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/Pods-AFNetworking_LinkFileList.html">Pods-AFNetworking.LinkFileList</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIActivityIndicatorView+AFNetworking_d.html">UIActivityIndicatorView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIAlertView+AFNetworking_d.html">UIAlertView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIButton+AFNetworking_d.html">UIButton+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIImageView+AFNetworking_d.html">UIImageView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIProgressView+AFNetworking_d.html">UIProgressView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIRefreshControl+AFNetworking_d.html">UIRefreshControl+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIWebView+AFNetworking_d.html">UIWebView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFHTTPRequestOperation_d.html">AFHTTPRequestOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFHTTPRequestOperationManager_d.html">AFHTTPRequestOperationManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFHTTPSessionManager_d.html">AFHTTPSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFNetworkActivityIndicatorManager_d.html">AFNetworkActivityIndicatorManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFNetworkReachabilityManager_d.html">AFNetworkReachabilityManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFSecurityPolicy_d.html">AFSecurityPolicy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLConnectionOperation_d.html">AFURLConnectionOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLRequestSerialization_d.html">AFURLRequestSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLResponseSerialization_d.html">AFURLResponseSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLSessionManager_d.html">AFURLSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/Pods-AFNetworking-dummy_d.html">Pods-AFNetworking-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/Pods-AFNetworking_LinkFileList.html">Pods-AFNetworking.LinkFileList</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIActivityIndicatorView+AFNetworking_d.html">UIActivityIndicatorView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIAlertView+AFNetworking_d.html">UIAlertView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIButton+AFNetworking_d.html">UIButton+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIImageView+AFNetworking_d.html">UIImageView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIProgressView+AFNetworking_d.html">UIProgressView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIRefreshControl+AFNetworking_d.html">UIRefreshControl+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIWebView+AFNetworking_d.html">UIWebView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/i386/Pods-dummy_d.html">Pods-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/i386/Pods_LinkFileList.html">Pods.LinkFileList</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/x86_64/Pods-dummy_d.html">Pods-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/x86_64/Pods_LinkFileList.html">Pods.LinkFileList</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page vendor/Pods/AFNetworking/AFNetworking/AFURLSessionManager.m">

<p>// AFURLSessionManager.m // Copyright © 2011–2015 Alamofire Software
Foundation (<a href="http://alamofire.org">alamofire.org</a>/) // //
Permission is hereby granted, free of charge, to any person obtaining a
copy // of this software and associated documentation files (the
“Software”), to deal // in the Software without restriction, including
without limitation the rights // to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell // copies of the Software, and to
permit persons to whom the Software is // furnished to do so, subject to
the following conditions: // // The above copyright notice and this
permission notice shall be included in // all copies or substantial
portions of the Software. // // THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT
WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO
THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE.</p>

<p>import “AFURLSessionManager.h” import &lt;objc/runtime.h&gt;</p>

<p>if (defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp;
__IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000) ||
(defined(__MAC_OS_X_VERSION_MAX_ALLOWED) &amp;&amp;
__MAC_OS_X_VERSION_MAX_ALLOWED &gt;= 1090)</p>

<p>static dispatch_queue_t url_session_manager_creation_queue() {</p>

<pre>static dispatch_queue_t af_url_session_manager_creation_queue;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    af_url_session_manager_creation_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.creation&quot;, DISPATCH_QUEUE_SERIAL);
});

return af_url_session_manager_creation_queue;</pre>

<p>}</p>

<p>static dispatch_queue_t url_session_manager_processing_queue() {</p>

<pre>static dispatch_queue_t af_url_session_manager_processing_queue;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    af_url_session_manager_processing_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT);
});

return af_url_session_manager_processing_queue;</pre>

<p>}</p>

<p>static dispatch_group_t url_session_manager_completion_group() {</p>

<pre>static dispatch_group_t af_url_session_manager_completion_group;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    af_url_session_manager_completion_group = dispatch_group_create();
});

return af_url_session_manager_completion_group;</pre>

<p>}</p>

<p>NSString * const AFNetworkingTaskDidResumeNotification =
@“com.alamofire.networking.task.resume”; NSString * const
AFNetworkingTaskDidCompleteNotification =
@“com.alamofire.networking.task.complete”; NSString * const
AFNetworkingTaskDidSuspendNotification =
@“com.alamofire.networking.task.suspend”; NSString * const
AFURLSessionDidInvalidateNotification =
@“com.alamofire.networking.session.invalidate”; NSString * const
AFURLSessionDownloadTaskDidFailToMoveFileNotification =
@“com.alamofire.networking.session.download.file-manager-error”;</p>

<p>NSString * const AFNetworkingTaskDidStartNotification =
@“com.alamofire.networking.task.resume”; // Deprecated NSString * const
AFNetworkingTaskDidFinishNotification =
@“com.alamofire.networking.task.complete”; // Deprecated</p>

<p>NSString * const AFNetworkingTaskDidCompleteSerializedResponseKey =
@“com.alamofire.networking.task.complete.serializedresponse”; NSString *
const AFNetworkingTaskDidCompleteResponseSerializerKey =
@“com.alamofire.networking.task.complete.responseserializer”; NSString *
const AFNetworkingTaskDidCompleteResponseDataKey =
@“com.alamofire.networking.complete.finish.responsedata”; NSString * const
AFNetworkingTaskDidCompleteErrorKey =
@“com.alamofire.networking.task.complete.error”; NSString * const
AFNetworkingTaskDidCompleteAssetPathKey =
@“com.alamofire.networking.task.complete.assetpath”;</p>

<p>NSString * const AFNetworkingTaskDidFinishSerializedResponseKey =
@“com.alamofire.networking.task.complete.serializedresponse”; // Deprecated
NSString * const AFNetworkingTaskDidFinishResponseSerializerKey =
@“com.alamofire.networking.task.complete.responseserializer”; // Deprecated
NSString * const AFNetworkingTaskDidFinishResponseDataKey =
@“com.alamofire.networking.complete.finish.responsedata”; // Deprecated
NSString * const AFNetworkingTaskDidFinishErrorKey =
@“com.alamofire.networking.task.complete.error”; // Deprecated NSString *
const AFNetworkingTaskDidFinishAssetPathKey =
@“com.alamofire.networking.task.complete.assetpath”; // Deprecated</p>

<p>static NSString * const AFURLSessionManagerLockName =
@“com.alamofire.networking.session.manager.lock”;</p>

<p>static NSUInteger const
AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask = 3;</p>

<p>static void * AFTaskStateChangedContext = &amp;AFTaskStateChangedContext;</p>

<p>typedef void (^AFURLSessionDidBecomeInvalidBlock)(NSURLSession *session,
NSError *error); typedef NSURLSessionAuthChallengeDisposition
(^AFURLSessionDidReceiveAuthenticationChallengeBlock)(NSURLSession
*session, NSURLAuthenticationChallenge *challenge, NSURLCredential *
__autoreleasing *credential);</p>

<p>typedef NSURLRequest *
(^AFURLSessionTaskWillPerformHTTPRedirectionBlock)(NSURLSession *session,
NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request);
typedef NSURLSessionAuthChallengeDisposition
(^AFURLSessionTaskDidReceiveAuthenticationChallengeBlock)(NSURLSession
*session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge,
NSURLCredential * __autoreleasing *credential); typedef void
(^AFURLSessionDidFinishEventsForBackgroundURLSessionBlock)(NSURLSession
*session);</p>

<p>typedef NSInputStream *
(^AFURLSessionTaskNeedNewBodyStreamBlock)(NSURLSession *session,
NSURLSessionTask *task); typedef void
(^AFURLSessionTaskDidSendBodyDataBlock)(NSURLSession *session,
NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t
totalBytesExpectedToSend); typedef void
(^AFURLSessionTaskDidCompleteBlock)(NSURLSession *session, NSURLSessionTask
*task, NSError *error);</p>

<p>typedef NSURLSessionResponseDisposition
(^AFURLSessionDataTaskDidReceiveResponseBlock)(NSURLSession *session,
NSURLSessionDataTask *dataTask, NSURLResponse *response); typedef void
(^AFURLSessionDataTaskDidBecomeDownloadTaskBlock)(NSURLSession *session,
NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask);
typedef void (^AFURLSessionDataTaskDidReceiveDataBlock)(NSURLSession
*session, NSURLSessionDataTask *dataTask, NSData *data); typedef
NSCachedURLResponse *
(^AFURLSessionDataTaskWillCacheResponseBlock)(NSURLSession *session,
NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse);</p>

<p>typedef NSURL *
(^AFURLSessionDownloadTaskDidFinishDownloadingBlock)(NSURLSession *session,
NSURLSessionDownloadTask *downloadTask, NSURL *location); typedef void
(^AFURLSessionDownloadTaskDidWriteDataBlock)(NSURLSession *session,
NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t
totalBytesWritten, int64_t totalBytesExpectedToWrite); typedef void
(^AFURLSessionDownloadTaskDidResumeBlock)(NSURLSession *session,
NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t
expectedTotalBytes);</p>

<p>typedef void (^AFURLSessionTaskCompletionHandler)(NSURLResponse *response,
id responseObject, NSError *error);</p>

<p>pragma mark -</p>

<p>@interface AFURLSessionManagerTaskDelegate : NSObject
&lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate,
NSURLSessionDownloadDelegate&gt; @property (nonatomic, weak)
AFURLSessionManager *manager; @property (nonatomic, strong) NSMutableData
*mutableData; @property (nonatomic, strong) NSProgress *progress; @property
(nonatomic, copy) NSURL *downloadFileURL; @property (nonatomic, copy)
AFURLSessionDownloadTaskDidFinishDownloadingBlock
downloadTaskDidFinishDownloading; @property (nonatomic, copy)
AFURLSessionTaskCompletionHandler completionHandler; @end</p>

<p>@implementation AFURLSessionManagerTaskDelegate</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

self.mutableData = [NSMutableData data];

self.progress = [NSProgress progressWithTotalUnitCount:0];

return self;</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSURLSessionTaskDelegate</p>
<ul><li>
<p>(void)URLSession:(__unused NSURLSession *)session</p>

<pre>           task:(__unused NSURLSessionTask *)task
didSendBodyData:(__unused int64_t)bytesSent
 totalBytesSent:(int64_t)totalBytesSent</pre>
</li></ul>

<p>totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">progress</span>.<span class="ruby-identifier">totalUnitCount</span> = <span class="ruby-identifier">totalBytesExpectedToSend</span>;
<span class="ruby-keyword">self</span>.<span class="ruby-identifier">progress</span>.<span class="ruby-identifier">completedUnitCount</span> = <span class="ruby-identifier">totalBytesSent</span>;
</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(__unused NSURLSession *)session</p>

<pre>task:(NSURLSessionTask *)task</pre>
</li></ul>

<p>didCompleteWithError:(NSError *)error { pragma clang diagnostic push pragma
clang diagnostic ignored “-Wgnu”</p>

<pre>__strong AFURLSessionManager *manager = self.manager;

__block id responseObject = nil;

__block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;

if (self.downloadFileURL) {
    userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
} else if (self.mutableData) {
    userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = [NSData dataWithData:self.mutableData];
}

if (error) {
    userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;

    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
        if (self.completionHandler) {
            self.completionHandler(task.response, responseObject, error);
        }

        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
        });
    });
} else {
    dispatch_async(url_session_manager_processing_queue(), ^{
        NSError *serializationError = nil;
        responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:[NSData dataWithData:self.mutableData] error:&amp;serializationError];

        if (self.downloadFileURL) {
            responseObject = self.downloadFileURL;
        }

        if (responseObject) {
            userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
        }

        if (serializationError) {
            userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
        }

        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{
            if (self.completionHandler) {
                self.completionHandler(task.response, responseObject, serializationError);
            }

            dispatch_async(dispatch_get_main_queue(), ^{
                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
            });
        });
    });
}</pre>

<p>pragma clang diagnostic pop }</p>

<p>pragma mark - NSURLSessionDataTaskDelegate</p>
<ul><li>
<p>(void)URLSession:(__unused NSURLSession *)session</p>

<pre>      dataTask:(__unused NSURLSessionDataTask *)dataTask
didReceiveData:(NSData *)data</pre>
</li></ul>

<p>{</p>

<pre>[self.mutableData appendData:data];</pre>

<p>}</p>

<p>pragma mark - NSURLSessionDownloadTaskDelegate</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>downloadTask:(NSURLSessionDownloadTask *)downloadTask</pre>
</li></ul>

<p>didFinishDownloadingToURL:(NSURL *)location {</p>

<pre>NSError *fileManagerError = nil;
self.downloadFileURL = nil;

if (self.downloadTaskDidFinishDownloading) {
    self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
    if (self.downloadFileURL) {
        [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];

        if (fileManagerError) {
            [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];
        }
    }
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(__unused NSURLSession *)session</p>

<pre>downloadTask:(__unused NSURLSessionDownloadTask *)downloadTask
didWriteData:(__unused int64_t)bytesWritten</pre>
</li></ul>

<pre>totalBytesWritten:(int64_t)totalBytesWritten</pre>

<p>totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">progress</span>.<span class="ruby-identifier">totalUnitCount</span> = <span class="ruby-identifier">totalBytesExpectedToWrite</span>;
<span class="ruby-keyword">self</span>.<span class="ruby-identifier">progress</span>.<span class="ruby-identifier">completedUnitCount</span> = <span class="ruby-identifier">totalBytesWritten</span>;
</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(__unused NSURLSession *)session</p>

<pre>downloadTask:(__unused NSURLSessionDownloadTask *)downloadTask</pre>
</li></ul>

<pre>didResumeAtOffset:(int64_t)fileOffset</pre>

<p>expectedTotalBytes:(int64_t)expectedTotalBytes {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">progress</span>.<span class="ruby-identifier">totalUnitCount</span> = <span class="ruby-identifier">expectedTotalBytes</span>;
<span class="ruby-keyword">self</span>.<span class="ruby-identifier">progress</span>.<span class="ruby-identifier">completedUnitCount</span> = <span class="ruby-identifier">fileOffset</span>;
</pre>

<p>}</p>

<p>@end</p>

<p>pragma mark -</p>

<pre>A workaround for issues related to key-value observing the `state` of an `NSURLSessionTask`.

See:
- https://github.com/AFNetworking/AFNetworking/issues/1477
- https://github.com/AFNetworking/AFNetworking/issues/2638
- https://github.com/AFNetworking/AFNetworking/pull/2702</pre>

<p>static inline void af_swizzleSelector(Class class, SEL originalSelector,
SEL swizzledSelector) {</p>

<pre>Method originalMethod = class_getInstanceMethod(class, originalSelector);
Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
method_exchangeImplementations(originalMethod, swizzledMethod);</pre>

<p>}</p>

<p>static inline BOOL af_addMethod(Class class, SEL selector, Method method) {</p>

<pre>return class_addMethod(class, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</pre>

<p>}</p>

<p>static NSString * const AFNSURLSessionTaskDidResumeNotification  =
@“com.alamofire.networking.nsurlsessiontask.resume”; static NSString *
const AFNSURLSessionTaskDidSuspendNotification =
@“com.alamofire.networking.nsurlsessiontask.suspend”;</p>

<p>@interface _AFURLSessionTaskSwizzling : NSObject</p>

<p>@end</p>

<p>@implementation _AFURLSessionTaskSwizzling</p>

<p>+ (void)load {</p>

<pre>/**
 WARNING: Trouble Ahead
 https://github.com/AFNetworking/AFNetworking/pull/2702
  /

if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) {
    /**
     iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky.
     Many Unit Tests have been built to validate as much of this behavior has possible.
     Here is what we know:
        - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn&#39;t actually the type of class you will get back.
        - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there.
        - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`.
        - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`.
        - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled.
        - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled.
        - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there.

     Some Assumptions:
        - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we&#39;d need to handle it.
        - No background task classes override `resume` or `suspend`

     The current solution:
        1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task.
        2) Grab a pointer to the original implementation of `af_resume`
        3) Check to see if the current class has an implementation of resume. If so, continue to step 4.
        4) Grab the super class of the current class.
        5) Grab a pointer for the current class to the current implementation of `resume`.
        6) Grab a pointer for the super class to the current implementation of `resume`.
        7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods
        8) Set the current class to the super class, and repeat steps 3-8
      /
    NSURLSessionDataTask *localDataTask = [[NSURLSession sessionWithConfiguration:nil] dataTaskWithURL:nil];
    IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([_AFURLSessionTaskSwizzling class], @selector(af_resume)));
    Class currentClass = [localDataTask class];

    while (class_getInstanceMethod(currentClass, @selector(resume))) {
        Class superClass = [currentClass superclass];
        IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));
        IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));
        if (classResumeIMP != superclassResumeIMP &amp;&amp;
            originalAFResumeIMP != classResumeIMP) {
            [self swizzleResumeAndSuspendMethodForClass:currentClass];
        }
        currentClass = [currentClass superclass];
    }

    [localDataTask cancel];
}</pre>

<p>}</p>

<p>+ (void)swizzleResumeAndSuspendMethodForClass:(Class)class {</p>

<pre>Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));
Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));

af_addMethod(class, @selector(af_resume), afResumeMethod);
af_addMethod(class, @selector(af_suspend), afSuspendMethod);

af_swizzleSelector(class, @selector(resume), @selector(af_resume));
af_swizzleSelector(class, @selector(suspend), @selector(af_suspend));</pre>

<p>}</p>
<ul><li>
<p>(NSURLSessionTaskState)state {</p>

<pre>NSAssert(NO, @&quot;State method should never be called in the actual dummy class&quot;);
return NSURLSessionTaskStateCanceling;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)af_resume {</p>

<pre>NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);
NSURLSessionTaskState state = [self state];
[self af_resume];

if (state != NSURLSessionTaskStateRunning) {
    [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];
}</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)af_suspend {</p>

<pre>NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);
NSURLSessionTaskState state = [self state];
[self af_suspend];

if (state != NSURLSessionTaskStateSuspended) {
    [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];
}</pre>
</li></ul>

<p>} @end</p>

<p>pragma mark -</p>

<p>@interface AFURLSessionManager () @property (readwrite, nonatomic, strong)
NSURLSessionConfiguration *sessionConfiguration; @property (readwrite,
nonatomic, strong) NSOperationQueue *operationQueue; @property (readwrite,
nonatomic, strong) NSURLSession *session; @property (readwrite, nonatomic,
strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;
@property (readonly, nonatomic, copy) NSString
*taskDescriptionForSessionTasks; @property (readwrite, nonatomic, strong)
NSLock *lock; @property (readwrite, nonatomic, copy)
AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid; @property
(readwrite, nonatomic, copy)
AFURLSessionDidReceiveAuthenticationChallengeBlock
sessionDidReceiveAuthenticationChallenge; @property (readwrite, nonatomic,
copy) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock
didFinishEventsForBackgroundURLSession; @property (readwrite, nonatomic,
copy) AFURLSessionTaskWillPerformHTTPRedirectionBlock
taskWillPerformHTTPRedirection; @property (readwrite, nonatomic, copy)
AFURLSessionTaskDidReceiveAuthenticationChallengeBlock
taskDidReceiveAuthenticationChallenge; @property (readwrite, nonatomic,
copy) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;
@property (readwrite, nonatomic, copy) AFURLSessionTaskDidSendBodyDataBlock
taskDidSendBodyData; @property (readwrite, nonatomic, copy)
AFURLSessionTaskDidCompleteBlock taskDidComplete; @property (readwrite,
nonatomic, copy) AFURLSessionDataTaskDidReceiveResponseBlock
dataTaskDidReceiveResponse; @property (readwrite, nonatomic, copy)
AFURLSessionDataTaskDidBecomeDownloadTaskBlock
dataTaskDidBecomeDownloadTask; @property (readwrite, nonatomic, copy)
AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData; @property
(readwrite, nonatomic, copy) AFURLSessionDataTaskWillCacheResponseBlock
dataTaskWillCacheResponse; @property (readwrite, nonatomic, copy)
AFURLSessionDownloadTaskDidFinishDownloadingBlock
downloadTaskDidFinishDownloading; @property (readwrite, nonatomic, copy)
AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;
@property (readwrite, nonatomic, copy)
AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume; @end</p>

<p>@implementation AFURLSessionManager</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>return [self initWithSessionConfiguration:nil];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration
*)configuration {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

if (!configuration) {
    configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
}

self.sessionConfiguration = configuration;

self.operationQueue = [[NSOperationQueue alloc] init];
self.operationQueue.maxConcurrentOperationCount = 1;

self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];

self.responseSerializer = [AFJSONResponseSerializer serializer];

self.securityPolicy = [AFSecurityPolicy defaultPolicy];

self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];

self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

self.lock = [[NSLock alloc] init];
self.lock.name = AFURLSessionManagerLockName;

[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
    for (NSURLSessionDataTask *task in dataTasks) {
        [self addDelegateForDataTask:task completionHandler:nil];
    }

    for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
        [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
    }

    for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
        [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
    }
}];

[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidResume:) name:AFNSURLSessionTaskDidResumeNotification object:nil];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(taskDidSuspend:) name:AFNSURLSessionTaskDidSuspendNotification object:nil];

return self;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)dealloc {</p>

<pre>[[NSNotificationCenter defaultCenter] removeObserver:self];</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(NSString *)taskDescriptionForSessionTasks {</p>

<pre>return [NSString stringWithFormat:@&quot;%p&quot;, self];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)taskDidResume:(NSNotification *)notification {</p>

<pre>NSURLSessionTask *task = notification.object;
if ([task respondsToSelector:@selector(taskDescription)]) {
    if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidResumeNotification object:task];
        });
    }
}</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)taskDidSuspend:(NSNotification *)notification {</p>

<pre>NSURLSessionTask *task = notification.object;
if ([task respondsToSelector:@selector(taskDescription)]) {
    if ([task.taskDescription isEqualToString:self.taskDescriptionForSessionTasks]) {
        dispatch_async(dispatch_get_main_queue(), ^{
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidSuspendNotification object:task];
        });
    }
}</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task
{</p>

<pre>NSParameterAssert(task);

AFURLSessionManagerTaskDelegate *delegate = nil;
[self.lock lock];
delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];
[self.lock unlock];

return delegate;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</p>

<pre>forTask:(NSURLSessionTask *)task</pre>
</li></ul>

<p>{</p>

<pre>NSParameterAssert(task);
NSParameterAssert(delegate);

[self.lock lock];
self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;
[self.lock unlock];</pre>

<p>}</p>
<ul><li>
<p>(void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</p>

<pre>completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
delegate.manager = self;
delegate.completionHandler = completionHandler;

dataTask.taskDescription = self.taskDescriptionForSessionTasks;
[self setDelegate:delegate forTask:dataTask];</pre>

<p>}</p>
<ul><li>
<p>(void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask</p>

<pre>         progress:(NSProgress * __autoreleasing *)progress
completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
delegate.manager = self;
delegate.completionHandler = completionHandler;

int64_t totalUnitCount = uploadTask.countOfBytesExpectedToSend;
if(totalUnitCount == NSURLSessionTransferSizeUnknown) {
    NSString *contentLength = [uploadTask.originalRequest valueForHTTPHeaderField:@&quot;Content-Length&quot;];
    if(contentLength) {
        totalUnitCount = (int64_t)[contentLength longLongValue];
    }
}

if (delegate.progress) {
    delegate.progress.totalUnitCount = totalUnitCount;
} else {
    delegate.progress = [NSProgress progressWithTotalUnitCount:totalUnitCount];
}

delegate.progress.pausingHandler = ^{
    [uploadTask suspend];
};
delegate.progress.cancellationHandler = ^{
    [uploadTask cancel];
};

if (progress) {
     progress = delegate.progress;
}

uploadTask.taskDescription = self.taskDescriptionForSessionTasks;

[self setDelegate:delegate forTask:uploadTask];</pre>

<p>}</p>
<ul><li>
<p>(void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</p>

<pre>         progress:(NSProgress * __autoreleasing *)progress
      destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];
delegate.manager = self;
delegate.completionHandler = completionHandler;

if (destination) {
    delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) {
        return destination(location, task.response);
    };
}

if (progress) {
     progress = delegate.progress;
}

downloadTask.taskDescription = self.taskDescriptionForSessionTasks;

[self setDelegate:delegate forTask:downloadTask];</pre>

<p>}</p>
<ul><li>
<p>(void)removeDelegateForTask:(NSURLSessionTask *)task {</p>

<pre>NSParameterAssert(task);

[self.lock lock];
[self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];
[self.lock unlock];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)removeAllDelegates {</p>

<pre>[self.lock lock];
[self.mutableTaskDelegatesKeyedByTaskIdentifier removeAllObjects];
[self.lock unlock];</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(NSArray *)tasksForKeyPath:(NSString *)keyPath {</p>

<pre>__block NSArray *tasks = nil;
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
    if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {
        tasks = dataTasks;
    } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {
        tasks = uploadTasks;
    } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {
        tasks = downloadTasks;
    } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {
        tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];
    }

    dispatch_semaphore_signal(semaphore);
}];

dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

return tasks;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(NSArray *)tasks {</p>

<pre>return [self tasksForKeyPath:NSStringFromSelector(_cmd)];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(NSArray *)dataTasks {</p>

<pre>return [self tasksForKeyPath:NSStringFromSelector(_cmd)];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(NSArray *)uploadTasks {</p>

<pre>return [self tasksForKeyPath:NSStringFromSelector(_cmd)];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(NSArray *)downloadTasks {</p>

<pre>return [self tasksForKeyPath:NSStringFromSelector(_cmd)];</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks {</p>

<pre>dispatch_async(dispatch_get_main_queue(), ^{
    if (cancelPendingTasks) {
        [self.session invalidateAndCancel];
    } else {
        [self.session finishTasksAndInvalidate];
    }
});</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(void)setResponseSerializer:(id
&lt;AFURLResponseSerialization&gt;)responseSerializer {</p>

<pre class="ruby"><span class="ruby-constant">NSParameterAssert</span>(<span class="ruby-identifier">responseSerializer</span>);

<span class="ruby-identifier">_responseSerializer</span> = <span class="ruby-identifier">responseSerializer</span>;
</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</p>

<pre>completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>__block NSURLSessionDataTask *dataTask = nil;
dispatch_sync(url_session_manager_creation_queue(), ^{
    dataTask = [self.session dataTaskWithRequest:request];
});

[self addDelegateForDataTask:dataTask completionHandler:completionHandler];

return dataTask;</pre>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</p>

<pre>         fromFile:(NSURL *)fileURL
         progress:(NSProgress * __autoreleasing *)progress
completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>__block NSURLSessionUploadTask *uploadTask = nil;
dispatch_sync(url_session_manager_creation_queue(), ^{
    uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL];
});

if (!uploadTask &amp;&amp; self.attemptsToRecreateUploadTasksForBackgroundSessions &amp;&amp; self.session.configuration.identifier) {
    for (NSUInteger attempts = 0; !uploadTask &amp;&amp; attempts &lt; AFMaximumNumberOfAttemptsToRecreateBackgroundSessionUploadTask; attempts++) {
        uploadTask = [self.session uploadTaskWithRequest:request fromFile:fileURL];
    }
}

[self addDelegateForUploadTask:uploadTask progress:progress completionHandler:completionHandler];

return uploadTask;</pre>

<p>}</p>
<ul><li>
<p>(NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</p>

<pre>         fromData:(NSData *)bodyData
         progress:(NSProgress * __autoreleasing *)progress
completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>__block NSURLSessionUploadTask *uploadTask = nil;
dispatch_sync(url_session_manager_creation_queue(), ^{
    uploadTask = [self.session uploadTaskWithRequest:request fromData:bodyData];
});

[self addDelegateForUploadTask:uploadTask progress:progress completionHandler:completionHandler];

return uploadTask;</pre>

<p>}</p>
<ul><li>
<p>(NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest
*)request</p>

<pre>         progress:(NSProgress * __autoreleasing *)progress
completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>__block NSURLSessionUploadTask *uploadTask = nil;
dispatch_sync(url_session_manager_creation_queue(), ^{
    uploadTask = [self.session uploadTaskWithStreamedRequest:request];
});

[self addDelegateForUploadTask:uploadTask progress:progress completionHandler:completionHandler];

return uploadTask;</pre>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</p>

<pre>         progress:(NSProgress * __autoreleasing *)progress
      destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>__block NSURLSessionDownloadTask *downloadTask = nil;
dispatch_sync(url_session_manager_creation_queue(), ^{
    downloadTask = [self.session downloadTaskWithRequest:request];
});

[self addDelegateForDownloadTask:downloadTask progress:progress destination:destination completionHandler:completionHandler];

return downloadTask;</pre>

<p>}</p>
<ul><li>
<p>(NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData</p>

<pre>         progress:(NSProgress * __autoreleasing *)progress
      destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</pre>
</li></ul>

<p>{</p>

<pre>__block NSURLSessionDownloadTask *downloadTask = nil;
dispatch_sync(url_session_manager_creation_queue(), ^{
    downloadTask = [self.session downloadTaskWithResumeData:resumeData];
});

[self addDelegateForDownloadTask:downloadTask progress:progress destination:destination completionHandler:completionHandler];

return downloadTask;</pre>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(NSProgress *)uploadProgressForTask:(NSURLSessionUploadTask *)uploadTask {</p>

<pre>return [[self delegateForTask:uploadTask] progress];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(NSProgress *)downloadProgressForTask:(NSURLSessionDownloadTask
*)downloadTask {</p>

<pre>return [[self delegateForTask:downloadTask] progress];</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(void)setSessionDidBecomeInvalidBlock:(void (^)(NSURLSession *session,
NSError *error))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">sessionDidBecomeInvalid</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setSessionDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition
(^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge,
NSURLCredential * __autoreleasing *credential))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">sessionDidReceiveAuthenticationChallenge</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setDidFinishEventsForBackgroundURLSessionBlock:(void (^)(NSURLSession
*session))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">didFinishEventsForBackgroundURLSession</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(void)setTaskNeedNewBodyStreamBlock:(NSInputStream * (^)(NSURLSession
*session, NSURLSessionTask *task))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">taskNeedNewBodyStream</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setTaskWillPerformHTTPRedirectionBlock:(NSURLRequest *
(^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response,
NSURLRequest *request))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">taskWillPerformHTTPRedirection</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setTaskDidReceiveAuthenticationChallengeBlock:(NSURLSessionAuthChallengeDisposition
(^)(NSURLSession *session, NSURLSessionTask *task,
NSURLAuthenticationChallenge *challenge, NSURLCredential * __autoreleasing
*credential))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">taskDidReceiveAuthenticationChallenge</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setTaskDidSendBodyDataBlock:(void (^)(NSURLSession *session,
NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t
totalBytesExpectedToSend))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">taskDidSendBodyData</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setTaskDidCompleteBlock:(void (^)(NSURLSession *session,
NSURLSessionTask *task, NSError *error))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">taskDidComplete</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(void)setDataTaskDidReceiveResponseBlock:(NSURLSessionResponseDisposition
(^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse
*response))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">dataTaskDidReceiveResponse</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setDataTaskDidBecomeDownloadTaskBlock:(void (^)(NSURLSession
*session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask
*downloadTask))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">dataTaskDidBecomeDownloadTask</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setDataTaskDidReceiveDataBlock:(void (^)(NSURLSession *session,
NSURLSessionDataTask *dataTask, NSData *data))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">dataTaskDidReceiveData</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setDataTaskWillCacheResponseBlock:(NSCachedURLResponse *
(^)(NSURLSession *session, NSURLSessionDataTask *dataTask,
NSCachedURLResponse *proposedResponse))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">dataTaskWillCacheResponse</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(void)setDownloadTaskDidFinishDownloadingBlock:(NSURL * (^)(NSURLSession
*session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">downloadTaskDidFinishDownloading</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setDownloadTaskDidWriteDataBlock:(void (^)(NSURLSession *session,
NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t
totalBytesWritten, int64_t totalBytesExpectedToWrite))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">downloadTaskDidWriteData</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)setDownloadTaskDidResumeBlock:(void (^)(NSURLSession *session,
NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t
expectedTotalBytes))block {</p>

<pre class="ruby"><span class="ruby-keyword">self</span>.<span class="ruby-identifier">downloadTaskDidResume</span> = <span class="ruby-identifier">block</span>;
</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSObject</p>
<ul><li>
<p>(NSString *)description {</p>

<pre>return [NSString stringWithFormat:@&quot;&lt;%@: %p, session: %@, operationQueue: %@&gt;&quot;, NSStringFromClass([self class]), self, self.session, self.operationQueue];</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(BOOL)respondsToSelector:(SEL)selector {</p>

<pre>if (selector == @selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)) {
    return self.taskWillPerformHTTPRedirection != nil;
} else if (selector == @selector(URLSession:dataTask:didReceiveResponse:completionHandler:)) {
    return self.dataTaskDidReceiveResponse != nil;
} else if (selector == @selector(URLSession:dataTask:willCacheResponse:completionHandler:)) {
    return self.dataTaskWillCacheResponse != nil;
} else if (selector == @selector(URLSessionDidFinishEventsForBackgroundURLSession:)) {
    return self.didFinishEventsForBackgroundURLSession != nil;
}

return [[self class] instancesRespondToSelector:selector];</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSURLSessionDelegate</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>
</li></ul>

<p>didBecomeInvalidWithError:(NSError *)error {</p>

<pre>if (self.sessionDidBecomeInvalid) {
    self.sessionDidBecomeInvalid(session, error);
}

[self removeAllDelegates];
[[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>
</li></ul>

<p>didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</p>

<pre>completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</pre>

<p>{</p>

<pre>NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
__block NSURLCredential *credential = nil;

if (self.sessionDidReceiveAuthenticationChallenge) {
    disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);
} else {
    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
        if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
            credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
            if (credential) {
                disposition = NSURLSessionAuthChallengeUseCredential;
            } else {
                disposition = NSURLSessionAuthChallengePerformDefaultHandling;
            }
        } else {
            disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
        }
    } else {
        disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    }
}

if (completionHandler) {
    completionHandler(disposition, credential);
}</pre>

<p>}</p>

<p>pragma mark - NSURLSessionTaskDelegate</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>task:(NSURLSessionTask *)task</pre>
</li></ul>

<p>willPerformHTTPRedirection:(NSHTTPURLResponse *)response</p>

<pre>       newRequest:(NSURLRequest *)request
completionHandler:(void (^)(NSURLRequest *))completionHandler</pre>

<p>{</p>

<pre>NSURLRequest *redirectRequest = request;

if (self.taskWillPerformHTTPRedirection) {
    redirectRequest = self.taskWillPerformHTTPRedirection(session, task, response, request);
}

if (completionHandler) {
    completionHandler(redirectRequest);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>task:(NSURLSessionTask *)task</pre>
</li></ul>

<p>didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</p>

<pre>completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</pre>

<p>{</p>

<pre>NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
__block NSURLCredential *credential = nil;

if (self.taskDidReceiveAuthenticationChallenge) {
    disposition = self.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);
} else {
    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
        if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) {
            disposition = NSURLSessionAuthChallengeUseCredential;
            credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];
        } else {
            disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
        }
    } else {
        disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    }
}

if (completionHandler) {
    completionHandler(disposition, credential);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>task:(NSURLSessionTask *)task</pre>
</li></ul>

<pre>needNewBodyStream:(void (^)(NSInputStream *bodyStream))completionHandler</pre>

<p>{</p>

<pre>NSInputStream *inputStream = nil;

if (self.taskNeedNewBodyStream) {
    inputStream = self.taskNeedNewBodyStream(session, task);
} else if (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:@protocol(NSCopying)]) {
    inputStream = [task.originalRequest.HTTPBodyStream copy];
}

if (completionHandler) {
    completionHandler(inputStream);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>           task:(NSURLSessionTask *)task
didSendBodyData:(int64_t)bytesSent
 totalBytesSent:(int64_t)totalBytesSent</pre>
</li></ul>

<p>totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend {</p>

<pre>int64_t totalUnitCount = totalBytesExpectedToSend;
if(totalUnitCount == NSURLSessionTransferSizeUnknown) {
    NSString *contentLength = [task.originalRequest valueForHTTPHeaderField:@&quot;Content-Length&quot;];
    if(contentLength) {
        totalUnitCount = (int64_t) [contentLength longLongValue];
    }
}

AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];
[delegate URLSession:session task:task didSendBodyData:bytesSent totalBytesSent:totalBytesSent totalBytesExpectedToSend:totalUnitCount];

if (self.taskDidSendBodyData) {
    self.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>task:(NSURLSessionTask *)task</pre>
</li></ul>

<p>didCompleteWithError:(NSError *)error {</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];

// delegate may be nil when completing a task in the background
if (delegate) {
    [delegate URLSession:session task:task didCompleteWithError:error];

    [self removeDelegateForTask:task];
}

if (self.taskDidComplete) {
    self.taskDidComplete(session, task, error);
}</pre>

<p>}</p>

<p>pragma mark - NSURLSessionDataDelegate</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>dataTask:(NSURLSessionDataTask *)dataTask</pre>
</li></ul>

<p>didReceiveResponse:(NSURLResponse *)response</p>

<pre>completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler</pre>

<p>{</p>

<pre>NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;

if (self.dataTaskDidReceiveResponse) {
    disposition = self.dataTaskDidReceiveResponse(session, dataTask, response);
}

if (completionHandler) {
    completionHandler(disposition);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>dataTask:(NSURLSessionDataTask *)dataTask</pre>
</li></ul>

<p>didBecomeDownloadTask:(NSURLSessionDownloadTask *)downloadTask {</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
if (delegate) {
    [self removeDelegateForTask:dataTask];
    [self setDelegate:delegate forTask:downloadTask];
}

if (self.dataTaskDidBecomeDownloadTask) {
    self.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>      dataTask:(NSURLSessionDataTask *)dataTask
didReceiveData:(NSData *)data</pre>
</li></ul>

<p>{</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:dataTask];
[delegate URLSession:session dataTask:dataTask didReceiveData:data];

if (self.dataTaskDidReceiveData) {
    self.dataTaskDidReceiveData(session, dataTask, data);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>dataTask:(NSURLSessionDataTask *)dataTask</pre>
</li></ul>

<pre>willCacheResponse:(NSCachedURLResponse *)proposedResponse
completionHandler:(void (^)(NSCachedURLResponse *cachedResponse))completionHandler</pre>

<p>{</p>

<pre>NSCachedURLResponse *cachedResponse = proposedResponse;

if (self.dataTaskWillCacheResponse) {
    cachedResponse = self.dataTaskWillCacheResponse(session, dataTask, proposedResponse);
}

if (completionHandler) {
    completionHandler(cachedResponse);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession
*)session {</p>

<pre>if (self.didFinishEventsForBackgroundURLSession) {
    dispatch_async(dispatch_get_main_queue(), ^{
        self.didFinishEventsForBackgroundURLSession(session);
    });
}</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSURLSessionDownloadDelegate</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>downloadTask:(NSURLSessionDownloadTask *)downloadTask</pre>
</li></ul>

<p>didFinishDownloadingToURL:(NSURL *)location {</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
if (self.downloadTaskDidFinishDownloading) {
    NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
    if (fileURL) {
        delegate.downloadFileURL = fileURL;
        NSError *error = nil;
        [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];
        if (error) {
            [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];
        }

        return;
    }
}

if (delegate) {
    [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>downloadTask:(NSURLSessionDownloadTask *)downloadTask
didWriteData:(int64_t)bytesWritten</pre>
</li></ul>

<pre>totalBytesWritten:(int64_t)totalBytesWritten</pre>

<p>totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
[delegate URLSession:session downloadTask:downloadTask didWriteData:bytesWritten totalBytesWritten:totalBytesWritten totalBytesExpectedToWrite:totalBytesExpectedToWrite];

if (self.downloadTaskDidWriteData) {
    self.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);
}</pre>

<p>}</p>
<ul><li>
<p>(void)URLSession:(NSURLSession *)session</p>

<pre>downloadTask:(NSURLSessionDownloadTask *)downloadTask</pre>
</li></ul>

<pre>didResumeAtOffset:(int64_t)fileOffset</pre>

<p>expectedTotalBytes:(int64_t)expectedTotalBytes {</p>

<pre>AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];
[delegate URLSession:session downloadTask:downloadTask didResumeAtOffset:fileOffset expectedTotalBytes:expectedTotalBytes];

if (self.downloadTaskDidResume) {
    self.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);
}</pre>

<p>}</p>

<p>pragma mark - NSSecureCoding</p>

<p>+ (BOOL)supportsSecureCoding {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">YES</span>;
</pre>

<p>}</p>
<ul><li>
<p>(id)initWithCoder:(NSCoder *)decoder {</p>

<pre>NSURLSessionConfiguration *configuration = [decoder decodeObjectOfClass:[NSURLSessionConfiguration class] forKey:@&quot;sessionConfiguration&quot;];

self = [self initWithSessionConfiguration:configuration];
if (!self) {
    return nil;
}

return self;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)encodeWithCoder:(NSCoder *)coder {</p>

<pre>[coder encodeObject:self.session.configuration forKey:@&quot;sessionConfiguration&quot;];</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSCopying</p>
<ul><li>
<p>(id)copyWithZone:(NSZone *)zone {</p>

<pre>return [[[self class] allocWithZone:zone] initWithSessionConfiguration:self.session.configuration];</pre>
</li></ul>

<p>}</p>

<p>@end</p>

<p>endif</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

