<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>AFURLResponseSerialization.m - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../../";
</script>

<script src="../../../../js/jquery.js"></script>
<script src="../../../../js/darkfish.js"></script>

<link href="../../../../css/fonts.css" rel="stylesheet">
<link href="../../../../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../../../app/controllers/main_view_controller_txt.html">main_view_controller</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_app/PkgInfo.html">PkgInfo</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_app/SintjansGemeenteApp_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_spec_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_spec_app/PkgInfo.html">PkgInfo</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/SintjansGemeenteApp_spec_app/SintjansGemeenteApp_spec_app_dSYM/Contents/Info_plist.html">Info.plist</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/objs/init_mm.html">init.mm</a>
  
    <li><a href="../../../../build/iPhoneSimulator-8_3-Development/objs/main_mm.html">main.mm</a>
  
    <li><a href="../../../../design/class structure.html">class structure</a>
  
    <li><a href="../../../../ib_xcodeproj/Stubs_m.html">Stubs.m</a>
  
    <li><a href="../../../../ib_xcodeproj/project_pbxproj.html">project.pbxproj</a>
  
    <li><a href="../../../../ib_xcodeproj/project_xcworkspace/contents_xcworkspacedata.html">contents.xcworkspacedata</a>
  
    <li><a href="../../../../ib_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/ib_xcscheme.html">ib.xcscheme</a>
  
    <li><a href="../../../../ib_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/xcschememanagement_plist.html">xcschememanagement.plist</a>
  
    <li><a href="../../../../requirements/product backlog.html">product backlog</a>
  
    <li><a href="../../../../resources/Main_storyboard.html">Main.storyboard</a>
  
    <li><a href="../../../../vendor/Podfile_lock.html">Podfile.lock</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperation_m.html">AFHTTPRequestOperation.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFHTTPRequestOperationManager_m.html">AFHTTPRequestOperationManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFHTTPSessionManager_m.html">AFHTTPSessionManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFNetworkReachabilityManager_m.html">AFNetworkReachabilityManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFSecurityPolicy_m.html">AFSecurityPolicy.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLConnectionOperation_m.html">AFURLConnectionOperation.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLRequestSerialization_m.html">AFURLRequestSerialization.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization_m.html">AFURLResponseSerialization.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/AFNetworking/AFURLSessionManager_m.html">AFURLSessionManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/LICENSE.html">LICENSE</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/README_md.html">README</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/AFNetworkActivityIndicatorManager_m.html">AFNetworkActivityIndicatorManager.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIActivityIndicatorView+AFNetworking_m.html">UIActivityIndicatorView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIAlertView+AFNetworking_m.html">UIAlertView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIButton+AFNetworking_m.html">UIButton+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIImageView+AFNetworking_m.html">UIImageView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIProgressView+AFNetworking_m.html">UIProgressView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIRefreshControl+AFNetworking_m.html">UIRefreshControl+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/AFNetworking/UIKit+AFNetworking/UIWebView+AFNetworking_m.html">UIWebView+AFNetworking.m</a>
  
    <li><a href="../../../../vendor/Pods/Manifest_lock.html">Manifest.lock</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/project_pbxproj.html">project.pbxproj</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/Pods-AFNetworking_xcscheme.html">Pods-AFNetworking.xcscheme</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/Pods_xcscheme.html">Pods.xcscheme</a>
  
    <li><a href="../../../../vendor/Pods/Pods_xcodeproj/xcuserdata/andreheijstek_xcuserdatad/xcschemes/xcschememanagement_plist.html">xcschememanagement.plist</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-Private_xcconfig.html">Pods-AFNetworking-Private.xcconfig</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-dummy_m.html">Pods-AFNetworking-dummy.m</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking-prefix_pch.html">Pods-AFNetworking-prefix.pch</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods-AFNetworking/Pods-AFNetworking_xcconfig.html">Pods-AFNetworking.xcconfig</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-acknowledgements_markdown.html">Pods-acknowledgements.markdown</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-acknowledgements_plist.html">Pods-acknowledgements.plist</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-dummy_m.html">Pods-dummy.m</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods-resources_sh.html">Pods-resources.sh</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods_debug_xcconfig.html">Pods.debug.xcconfig</a>
  
    <li><a href="../../../../vendor/Pods/Target Support Files/Pods/Pods_release_xcconfig.html">Pods.release.xcconfig</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFHTTPRequestOperation_d.html">AFHTTPRequestOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFHTTPRequestOperationManager_d.html">AFHTTPRequestOperationManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFHTTPSessionManager_d.html">AFHTTPSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFNetworkActivityIndicatorManager_d.html">AFNetworkActivityIndicatorManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFNetworkReachabilityManager_d.html">AFNetworkReachabilityManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFSecurityPolicy_d.html">AFSecurityPolicy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLConnectionOperation_d.html">AFURLConnectionOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLRequestSerialization_d.html">AFURLRequestSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLResponseSerialization_d.html">AFURLResponseSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/AFURLSessionManager_d.html">AFURLSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/Pods-AFNetworking-dummy_d.html">Pods-AFNetworking-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/Pods-AFNetworking_LinkFileList.html">Pods-AFNetworking.LinkFileList</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIActivityIndicatorView+AFNetworking_d.html">UIActivityIndicatorView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIAlertView+AFNetworking_d.html">UIAlertView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIButton+AFNetworking_d.html">UIButton+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIImageView+AFNetworking_d.html">UIImageView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIProgressView+AFNetworking_d.html">UIProgressView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIRefreshControl+AFNetworking_d.html">UIRefreshControl+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/i386/UIWebView+AFNetworking_d.html">UIWebView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFHTTPRequestOperation_d.html">AFHTTPRequestOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFHTTPRequestOperationManager_d.html">AFHTTPRequestOperationManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFHTTPSessionManager_d.html">AFHTTPSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFNetworkActivityIndicatorManager_d.html">AFNetworkActivityIndicatorManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFNetworkReachabilityManager_d.html">AFNetworkReachabilityManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFSecurityPolicy_d.html">AFSecurityPolicy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLConnectionOperation_d.html">AFURLConnectionOperation.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLRequestSerialization_d.html">AFURLRequestSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLResponseSerialization_d.html">AFURLResponseSerialization.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/AFURLSessionManager_d.html">AFURLSessionManager.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/Pods-AFNetworking-dummy_d.html">Pods-AFNetworking-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/Pods-AFNetworking_LinkFileList.html">Pods-AFNetworking.LinkFileList</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIActivityIndicatorView+AFNetworking_d.html">UIActivityIndicatorView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIAlertView+AFNetworking_d.html">UIAlertView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIButton+AFNetworking_d.html">UIButton+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIImageView+AFNetworking_d.html">UIImageView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIProgressView+AFNetworking_d.html">UIProgressView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIRefreshControl+AFNetworking_d.html">UIRefreshControl+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods-AFNetworking_build/Objects-normal/x86_64/UIWebView+AFNetworking_d.html">UIWebView+AFNetworking.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/i386/Pods-dummy_d.html">Pods-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/i386/Pods_LinkFileList.html">Pods.LinkFileList</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/x86_64/Pods-dummy_d.html">Pods-dummy.d</a>
  
    <li><a href="../../../../vendor/build/Pods_build/Release-iphonesimulator/Pods_build/Objects-normal/x86_64/Pods_LinkFileList.html">Pods.LinkFileList</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page vendor/Pods/AFNetworking/AFNetworking/AFURLResponseSerialization.m">

<p>// AFURLResponseSerialization.m // Copyright © 2011–2015 Alamofire Software
Foundation (<a href="http://alamofire.org">alamofire.org</a>/) // //
Permission is hereby granted, free of charge, to any person obtaining a
copy // of this software and associated documentation files (the
“Software”), to deal // in the Software without restriction, including
without limitation the rights // to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell // copies of the Software, and to
permit persons to whom the Software is // furnished to do so, subject to
the following conditions: // // The above copyright notice and this
permission notice shall be included in // all copies or substantial
portions of the Software. // // THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT
WARRANTY OF ANY KIND, EXPRESS OR // IMPLIED, INCLUDING BUT NOT LIMITED TO
THE WARRANTIES OF MERCHANTABILITY, // FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE // AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER // LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, // OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN // THE SOFTWARE.</p>

<p>import “AFURLResponseSerialization.h”</p>

<p>if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) import &lt;UIKit/UIKit.h&gt;
elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED) import &lt;Cocoa/Cocoa.h&gt;
endif</p>

<p>NSString * const AFURLResponseSerializationErrorDomain =
@“com.alamofire.error.serialization.response”; NSString * const
AFNetworkingOperationFailingURLResponseErrorKey =
@“com.alamofire.serialization.response.error.response”; NSString * const
AFNetworkingOperationFailingURLResponseDataErrorKey =
@“com.alamofire.serialization.response.error.data”;</p>

<p>static NSError * AFErrorWithUnderlyingError(NSError *error, NSError
*underlyingError) {</p>

<pre>if (!error) {
    return underlyingError;
}

if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) {
    return error;
}

NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];
mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;

return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</pre>

<p>}</p>

<p>static BOOL AFErrorOrUnderlyingErrorHasCodeInDomain(NSError *error,
NSInteger code, NSString *domain) {</p>

<pre>if ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) {
    return YES;
} else if (error.userInfo[NSUnderlyingErrorKey]) {
    return AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[NSUnderlyingErrorKey], code, domain);
}

return NO;</pre>

<p>}</p>

<p>static id AFJSONObjectByRemovingKeysWithNullValues(id JSONObject,
NSJSONReadingOptions readingOptions) {</p>

<pre>if ([JSONObject isKindOfClass:[NSArray class]]) {
    NSMutableArray *mutableArray = [NSMutableArray arrayWithCapacity:[(NSArray *)JSONObject count]];
    for (id value in (NSArray *)JSONObject) {
        [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];
    }

    return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableArray : [NSArray arrayWithArray:mutableArray];
} else if ([JSONObject isKindOfClass:[NSDictionary class]]) {
    NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionaryWithDictionary:JSONObject];
    for (id &lt;NSCopying&gt; key in [(NSDictionary *)JSONObject allKeys]) {
        id value = [(NSDictionary *)JSONObject objectForKey:key];
        if (!value || [value isEqual:[NSNull null]]) {
            [mutableDictionary removeObjectForKey:key];
        } else if ([value isKindOfClass:[NSArray class]] || [value isKindOfClass:[NSDictionary class]]) {
            [mutableDictionary setObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions) forKey:key];
        }
    }

    return (readingOptions &amp; NSJSONReadingMutableContainers) ? mutableDictionary : [NSDictionary dictionaryWithDictionary:mutableDictionary];
}

return JSONObject;</pre>

<p>}</p>

<p>@implementation AFHTTPResponseSerializer</p>

<p>+ (instancetype)serializer {</p>

<pre>return [[self alloc] init];</pre>

<p>}</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

self.stringEncoding = NSUTF8StringEncoding;

self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];
self.acceptableContentTypes = nil;

return self;</pre>
</li></ul>

<p>}</p>

<p>pragma mark -</p>
<ul><li>
<p>(BOOL)validateResponse:(NSHTTPURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError * __autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>BOOL responseIsValid = YES;
NSError *validationError = nil;

if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) {
    if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]]) {
        if ([data length] &gt; 0 &amp;&amp; [response URL]) {
            NSMutableDictionary *mutableUserInfo = [@{
                                                      NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],
                                                      NSURLErrorFailingURLErrorKey:[response URL],
                                                      AFNetworkingOperationFailingURLResponseErrorKey: response,
                                                    } mutableCopy];
            if (data) {
                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
            }

            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);
        }

        responseIsValid = NO;
    }

    if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) {
        NSMutableDictionary *mutableUserInfo = [@{
                                           NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],
                                           NSURLErrorFailingURLErrorKey:[response URL],
                                           AFNetworkingOperationFailingURLResponseErrorKey: response,
                                   } mutableCopy];

        if (data) {
            mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;
        }

        validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);

        responseIsValid = NO;
    }
}

if (error &amp;&amp; !responseIsValid) {
    *error = validationError;
}

return responseIsValid;</pre>

<p>}</p>

<p>pragma mark - AFURLResponseSerialization</p>
<ul><li>
<p>(id)responseObjectForResponse:(NSURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError *__autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>[self validateResponse:(NSHTTPURLResponse *)response data:data error:error];

return data;</pre>

<p>}</p>

<p>pragma mark - NSSecureCoding</p>

<p>+ (BOOL)supportsSecureCoding {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">YES</span>;
</pre>

<p>}</p>
<ul><li>
<p>(id)initWithCoder:(NSCoder *)decoder {</p>

<pre>self = [self init];
if (!self) {
    return nil;
}

self.acceptableStatusCodes = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
self.acceptableContentTypes = [decoder decodeObjectOfClass:[NSIndexSet class] forKey:NSStringFromSelector(@selector(acceptableContentTypes))];

return self;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)encodeWithCoder:(NSCoder *)coder {</p>

<pre>[coder encodeObject:self.acceptableStatusCodes forKey:NSStringFromSelector(@selector(acceptableStatusCodes))];
[coder encodeObject:self.acceptableContentTypes forKey:NSStringFromSelector(@selector(acceptableContentTypes))];</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSCopying</p>
<ul><li>
<p>(id)copyWithZone:(NSZone *)zone {</p>

<pre>AFHTTPResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
serializer.acceptableStatusCodes = [self.acceptableStatusCodes copyWithZone:zone];
serializer.acceptableContentTypes = [self.acceptableContentTypes copyWithZone:zone];

return serializer;</pre>
</li></ul>

<p>}</p>

<p>@end</p>

<p>pragma mark -</p>

<p>@implementation AFJSONResponseSerializer</p>

<p>+ (instancetype)serializer {</p>

<pre>return [self serializerWithReadingOptions:(NSJSONReadingOptions)0];</pre>

<p>}</p>

<p>+
(instancetype)serializerWithReadingOptions:(NSJSONReadingOptions)readingOptions
{</p>

<pre>AFJSONResponseSerializer *serializer = [[self alloc] init];
serializer.readingOptions = readingOptions;

return serializer;</pre>

<p>}</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];

return self;</pre>
</li></ul>

<p>}</p>

<p>pragma mark - AFURLResponseSerialization</p>
<ul><li>
<p>(id)responseObjectForResponse:(NSURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError *__autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        return nil;
    }
}

// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.
// See https://github.com/rails/rails/issues/1742
NSStringEncoding stringEncoding = self.stringEncoding;
if (response.textEncodingName) {
    CFStringEncoding encoding = CFStringConvertIANACharSetNameToEncoding((CFStringRef)response.textEncodingName);
    if (encoding != kCFStringEncodingInvalidId) {
        stringEncoding = CFStringConvertEncodingToNSStringEncoding(encoding);
    }
}

id responseObject = nil;
NSError *serializationError = nil;
@autoreleasepool {
    NSString *responseString = [[NSString alloc] initWithData:data encoding:stringEncoding];
    if (responseString &amp;&amp; ![responseString isEqualToString:@&quot; &quot;]) {
        // Workaround for a bug in NSJSONSerialization when Unicode character escape codes are used instead of the actual character
        // See http://stackoverflow.com/a/12843465/157142
        data = [responseString dataUsingEncoding:NSUTF8StringEncoding];

        if (data) {
            if ([data length] &gt; 0) {
                responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];
            } else {
                return nil;
            }
        } else {
            NSDictionary *userInfo = @{
                                       NSLocalizedDescriptionKey: NSLocalizedStringFromTable(@&quot;Data failed decoding as a UTF-8 string&quot;, @&quot;AFNetworking&quot;, nil),
                                       NSLocalizedFailureReasonErrorKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Could not decode string: %@&quot;, @&quot;AFNetworking&quot;, nil), responseString]
                                       };

            serializationError = [NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:userInfo];
        }
    }
}

if (self.removesKeysWithNullValues &amp;&amp; responseObject) {
    responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);
}

if (error) {
    *error = AFErrorWithUnderlyingError(serializationError, *error);
}

return responseObject;</pre>

<p>}</p>

<p>pragma mark - NSSecureCoding</p>
<ul><li>
<p>(id)initWithCoder:(NSCoder *)decoder {</p>

<pre>self = [super initWithCoder:decoder];
if (!self) {
    return nil;
}

self.readingOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readingOptions))] unsignedIntegerValue];
self.removesKeysWithNullValues = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))] boolValue];

return self;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)encodeWithCoder:(NSCoder *)coder {</p>

<pre>[super encodeWithCoder:coder];

[coder encodeObject:@(self.readingOptions) forKey:NSStringFromSelector(@selector(readingOptions))];
[coder encodeObject:@(self.removesKeysWithNullValues) forKey:NSStringFromSelector(@selector(removesKeysWithNullValues))];</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSCopying</p>
<ul><li>
<p>(id)copyWithZone:(NSZone *)zone {</p>

<pre>AFJSONResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
serializer.readingOptions = self.readingOptions;
serializer.removesKeysWithNullValues = self.removesKeysWithNullValues;

return serializer;</pre>
</li></ul>

<p>}</p>

<p>@end</p>

<p>pragma mark -</p>

<p>@implementation AFXMLParserResponseSerializer</p>

<p>+ (instancetype)serializer {</p>

<pre>AFXMLParserResponseSerializer *serializer = [[self alloc] init];

return serializer;</pre>

<p>}</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;application/xml&quot;, @&quot;text/xml&quot;, nil];

return self;</pre>
</li></ul>

<p>}</p>

<p>pragma mark - AFURLResponseSerialization</p>
<ul><li>
<p>(id)responseObjectForResponse:(NSHTTPURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError *__autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        return nil;
    }
}

return [[NSXMLParser alloc] initWithData:data];</pre>

<p>}</p>

<p>@end</p>

<p>pragma mark -</p>

<p>ifdef __MAC_OS_X_VERSION_MIN_REQUIRED</p>

<p>@implementation AFXMLDocumentResponseSerializer</p>

<p>+ (instancetype)serializer {</p>

<pre>return [self serializerWithXMLDocumentOptions:0];</pre>

<p>}</p>

<p>+ (instancetype)serializerWithXMLDocumentOptions:(NSUInteger)mask {</p>

<pre>AFXMLDocumentResponseSerializer *serializer = [[self alloc] init];
serializer.options = mask;

return serializer;</pre>

<p>}</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;application/xml&quot;, @&quot;text/xml&quot;, nil];

return self;</pre>
</li></ul>

<p>}</p>

<p>pragma mark - AFURLResponseSerialization</p>
<ul><li>
<p>(id)responseObjectForResponse:(NSURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError *__autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        return nil;
    }
}

NSError *serializationError = nil;
NSXMLDocument *document = [[NSXMLDocument alloc] initWithData:data options:self.options error:&amp;serializationError];

if (error) {
    *error = AFErrorWithUnderlyingError(serializationError, *error);
}

return document;</pre>

<p>}</p>

<p>pragma mark - NSSecureCoding</p>
<ul><li>
<p>(id)initWithCoder:(NSCoder *)decoder {</p>

<pre>self = [super initWithCoder:decoder];
if (!self) {
    return nil;
}

self.options = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(options))] unsignedIntegerValue];

return self;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)encodeWithCoder:(NSCoder *)coder {</p>

<pre>[super encodeWithCoder:coder];

[coder encodeObject:@(self.options) forKey:NSStringFromSelector(@selector(options))];</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSCopying</p>
<ul><li>
<p>(id)copyWithZone:(NSZone *)zone {</p>

<pre>AFXMLDocumentResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
serializer.options = self.options;

return serializer;</pre>
</li></ul>

<p>}</p>

<p>@end</p>

<p>endif</p>

<p>pragma mark -</p>

<p>@implementation AFPropertyListResponseSerializer</p>

<p>+ (instancetype)serializer {</p>

<pre>return [self serializerWithFormat:NSPropertyListXMLFormat_v1_0 readOptions:0];</pre>

<p>}</p>

<p>+ (instancetype)serializerWithFormat:(NSPropertyListFormat)format</p>

<pre>readOptions:(NSPropertyListReadOptions)readOptions</pre>

<p>{</p>

<pre>AFPropertyListResponseSerializer *serializer = [[self alloc] init];
serializer.format = format;
serializer.readOptions = readOptions;

return serializer;</pre>

<p>}</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;application/x-plist&quot;, nil];

return self;</pre>
</li></ul>

<p>}</p>

<p>pragma mark - AFURLResponseSerialization</p>
<ul><li>
<p>(id)responseObjectForResponse:(NSURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError *__autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        return nil;
    }
}

id responseObject;
NSError *serializationError = nil;

if (data) {
    responseObject = [NSPropertyListSerialization propertyListWithData:data options:self.readOptions format:NULL error:&amp;serializationError];
}

if (error) {
    *error = AFErrorWithUnderlyingError(serializationError, *error);
}

return responseObject;</pre>

<p>}</p>

<p>pragma mark - NSSecureCoding</p>
<ul><li>
<p>(id)initWithCoder:(NSCoder *)decoder {</p>

<pre>self = [super initWithCoder:decoder];
if (!self) {
    return nil;
}

self.format = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(format))] unsignedIntegerValue];
self.readOptions = [[decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(readOptions))] unsignedIntegerValue];

return self;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)encodeWithCoder:(NSCoder *)coder {</p>

<pre>[super encodeWithCoder:coder];

[coder encodeObject:@(self.format) forKey:NSStringFromSelector(@selector(format))];
[coder encodeObject:@(self.readOptions) forKey:NSStringFromSelector(@selector(readOptions))];</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSCopying</p>
<ul><li>
<p>(id)copyWithZone:(NSZone *)zone {</p>

<pre>AFPropertyListResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
serializer.format = self.format;
serializer.readOptions = self.readOptions;

return serializer;</pre>
</li></ul>

<p>}</p>

<p>@end</p>

<p>pragma mark -</p>

<p>if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) import
&lt;CoreGraphics/CoreGraphics.h&gt;</p>

<p>static UIImage * AFImageWithDataAtScale(NSData *data, CGFloat scale) {</p>

<pre>UIImage *image = [[UIImage alloc] initWithData:data];
if (image.images) {
    return image;
}

return [[UIImage alloc] initWithCGImage:[image CGImage] scale:scale orientation:image.imageOrientation];</pre>

<p>}</p>

<p>static UIImage *
AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response,
NSData *data, CGFloat scale) {</p>

<pre>if (!data || [data length] == 0) {
    return nil;
}

CGImageRef imageRef = NULL;
CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);

if ([response.MIMEType isEqualToString:@&quot;image/png&quot;]) {
    imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);
} else if ([response.MIMEType isEqualToString:@&quot;image/jpeg&quot;]) {
    imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);

    if (imageRef) {
        CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);
        CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);

        // CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScale
        if (imageColorSpaceModel == kCGColorSpaceModelCMYK) {
            CGImageRelease(imageRef);
            imageRef = NULL;
        }
    }
}

CGDataProviderRelease(dataProvider);

UIImage *image = AFImageWithDataAtScale(data, scale);
if (!imageRef) {
    if (image.images || !image) {
        return image;
    }

    imageRef = CGImageCreateCopy([image CGImage]);
    if (!imageRef) {
        return nil;
    }
}

size_t width = CGImageGetWidth(imageRef);
size_t height = CGImageGetHeight(imageRef);
size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);

if (width * height &gt; 1024 * 1024 || bitsPerComponent &gt; 8) {
    CGImageRelease(imageRef);

    return image;
}

// CGImageGetBytesPerRow() calculates incorrectly in iOS 5.0, so defer to CGBitmapContextCreate
size_t bytesPerRow = 0;
CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);
CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);

if (colorSpaceModel == kCGColorSpaceModelRGB) {
    uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</pre>

<p>pragma clang diagnostic push pragma clang diagnostic ignored
“-Wassign-enum”</p>

<pre>if (alpha == kCGImageAlphaNone) {
    bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;
    bitmapInfo |= kCGImageAlphaNoneSkipFirst;
} else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) {
    bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;
    bitmapInfo |= kCGImageAlphaPremultipliedFirst;
}</pre>

<p>pragma clang diagnostic pop</p>

<pre>}

CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);

CGColorSpaceRelease(colorSpace);

if (!context) {
    CGImageRelease(imageRef);

    return image;
}

CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);
CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);

CGContextRelease(context);

UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];

CGImageRelease(inflatedImageRef);
CGImageRelease(imageRef);

return inflatedImage;</pre>

<p>} endif</p>

<p>@implementation AFImageResponseSerializer</p>
<ul><li>
<p>(instancetype)init {</p>

<pre>self = [super init];
if (!self) {
    return nil;
}

self.acceptableContentTypes = [[NSSet alloc] initWithObjects:@&quot;image/tiff&quot;, @&quot;image/jpeg&quot;, @&quot;image/gif&quot;, @&quot;image/png&quot;, @&quot;image/ico&quot;, @&quot;image/x-icon&quot;, @&quot;image/bmp&quot;, @&quot;image/x-bmp&quot;, @&quot;image/x-xbitmap&quot;, @&quot;image/x-win-bitmap&quot;, nil];</pre>
</li></ul>

<p>if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)</p>

<pre>self.imageScale = [[UIScreen mainScreen] scale];
self.automaticallyInflatesResponseImage = YES;</pre>

<p>endif</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>;
</pre>

<p>}</p>

<p>pragma mark - AFURLResponseSerializer</p>
<ul><li>
<p>(id)responseObjectForResponse:(NSURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError *__autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) {
    if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) {
        return nil;
    }
}</pre>

<p>if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)</p>

<pre>if (self.automaticallyInflatesResponseImage) {
    return AFInflatedImageFromResponseWithDataAtScale((NSHTTPURLResponse *)response, data, self.imageScale);
} else {
    return AFImageWithDataAtScale(data, self.imageScale);
}</pre>

<p>elif defined(__MAC_OS_X_VERSION_MIN_REQUIRED)</p>

<pre>// Ensure that the image is set to it&#39;s correct pixel width and height
NSBitmapImageRep *bitimage = [[NSBitmapImageRep alloc] initWithData:data];
NSImage *image = [[NSImage alloc] initWithSize:NSMakeSize([bitimage pixelsWide], [bitimage pixelsHigh])];
[image addRepresentation:bitimage];

return image;</pre>

<p>endif</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-keyword">nil</span>;
</pre>

<p>}</p>

<p>pragma mark - NSSecureCoding</p>
<ul><li>
<p>(id)initWithCoder:(NSCoder *)decoder {</p>

<pre>self = [super initWithCoder:decoder];
if (!self) {
    return nil;
}</pre>
</li></ul>

<p>if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)</p>

<pre>NSNumber *imageScale = [decoder decodeObjectOfClass:[NSNumber class] forKey:NSStringFromSelector(@selector(imageScale))];</pre>

<p>if CGFLOAT_IS_DOUBLE</p>

<pre>self.imageScale = [imageScale doubleValue];</pre>

<p>else</p>

<pre>self.imageScale = [imageScale floatValue];</pre>

<p>endif</p>

<pre>self.automaticallyInflatesResponseImage = [decoder decodeBoolForKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];</pre>

<p>endif</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>;
</pre>

<p>}</p>
<ul><li>
<p>(void)encodeWithCoder:(NSCoder *)coder {</p>

<pre>[super encodeWithCoder:coder];</pre>
</li></ul>

<p>if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)</p>

<pre>[coder encodeObject:@(self.imageScale) forKey:NSStringFromSelector(@selector(imageScale))];
[coder encodeBool:self.automaticallyInflatesResponseImage forKey:NSStringFromSelector(@selector(automaticallyInflatesResponseImage))];</pre>

<p>endif }</p>

<p>pragma mark - NSCopying</p>
<ul><li>
<p>(id)copyWithZone:(NSZone *)zone {</p>

<pre>AFImageResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];</pre>
</li></ul>

<p>if defined(__IPHONE_OS_VERSION_MIN_REQUIRED)</p>

<pre class="ruby"><span class="ruby-identifier">serializer</span>.<span class="ruby-identifier">imageScale</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">imageScale</span>;
<span class="ruby-identifier">serializer</span>.<span class="ruby-identifier">automaticallyInflatesResponseImage</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">automaticallyInflatesResponseImage</span>;
</pre>

<p>endif</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">serializer</span>;
</pre>

<p>}</p>

<p>@end</p>

<p>pragma mark -</p>

<p>@interface AFCompoundResponseSerializer () @property (readwrite, nonatomic,
copy) NSArray *responseSerializers; @end</p>

<p>@implementation AFCompoundResponseSerializer</p>

<p>+ (instancetype)compoundSerializerWithResponseSerializers:(NSArray
*)responseSerializers {</p>

<pre>AFCompoundResponseSerializer *serializer = [[self alloc] init];
serializer.responseSerializers = responseSerializers;

return serializer;</pre>

<p>}</p>

<p>pragma mark - AFURLResponseSerialization</p>
<ul><li>
<p>(id)responseObjectForResponse:(NSURLResponse *)response</p>

<pre> data:(NSData *)data
error:(NSError *__autoreleasing *)error</pre>
</li></ul>

<p>{</p>

<pre>for (id &lt;AFURLResponseSerialization&gt; serializer in self.responseSerializers) {
    if (![serializer isKindOfClass:[AFHTTPResponseSerializer class]]) {
        continue;
    }

    NSError *serializerError = nil;
    id responseObject = [serializer responseObjectForResponse:response data:data error:&amp;serializerError];
    if (responseObject) {
        if (error) {
            *error = AFErrorWithUnderlyingError(serializerError, *error);
        }

        return responseObject;
    }
}

return [super responseObjectForResponse:response data:data error:error];</pre>

<p>}</p>

<p>pragma mark - NSSecureCoding</p>
<ul><li>
<p>(id)initWithCoder:(NSCoder *)decoder {</p>

<pre>self = [super initWithCoder:decoder];
if (!self) {
    return nil;
}

self.responseSerializers = [decoder decodeObjectOfClass:[NSArray class] forKey:NSStringFromSelector(@selector(responseSerializers))];

return self;</pre>
</li></ul>

<p>}</p>
<ul><li>
<p>(void)encodeWithCoder:(NSCoder *)coder {</p>

<pre>[super encodeWithCoder:coder];

[coder encodeObject:self.responseSerializers forKey:NSStringFromSelector(@selector(responseSerializers))];</pre>
</li></ul>

<p>}</p>

<p>pragma mark - NSCopying</p>
<ul><li>
<p>(id)copyWithZone:(NSZone *)zone {</p>

<pre>AFCompoundResponseSerializer *serializer = [[[self class] allocWithZone:zone] init];
serializer.responseSerializers = self.responseSerializers;

return serializer;</pre>
</li></ul>

<p>}</p>

<p>@end</p>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://docs.seattlerb.org/rdoc/">RDoc</a> 4.2.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

